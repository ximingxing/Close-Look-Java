# Graph

## 图论基础

图的基本存储方式：

1. 邻接表 -- LeetCode中的常见的存储方式

**做法**：我把每个节点`x`的邻居都存到一个列表里，然后把`x`和这个列表关联起来，这样就可以通过一个节点`x`找到它的所有相邻节点。
**优势**：占用存储空间少。
**劣势**：邻接表无法快速判断两个节点是否相邻。

2. 邻接矩阵

**做法**：邻接矩阵则是一个二维布尔数组`matrix`，如果节点`x`和`y`是相连的，那么就把`matrix[x][y]`设为`true`。
**优势**：快速判断两个节点是否相邻，如`matrix[1][3]=true`表示节点1和节点3相邻。
**劣势**：占用的存储空间大，如果图是稀疏的，则会浪费很多空间。

**有向加权图**的存储方式改进：

1. 对于邻接表来说，不仅存储节点`x`的全部邻居节点，还存储`x`到邻居节点的权重。

2. 对于邻接矩阵来说，将二维布尔数组转变为二位int或者float型数组，表示节点的权重。

**无向加权图**的存储方式改进：

对于无向图等价于**节点双向连接**，即`matrix[x][y] = true`和`matrix[y][x] = true`。

## 图的遍历

**由于图中可能存在环**，所以图的遍历需要借助`visited`数组。

```java
class Traverse {
    boolean[] visited; // Noting！

    void traverse(Graph graph, int s) {
        if (visited[s]) return;

        // 经过节点s
        visited[s] = true;
        // 遍历节点s的邻居节点
        for (Node node : graph.neighbors(s)) {
            traverse(neighbors);
        }
        //离开节点s
        visited[s] = false;
    }
}
```

---

### 判断有向图是否存在环

题目：#207

### 拓扑排序

定义: 给定一个包含`n`个节点的有向图`G`，我们给出它的节点编号的一种排列，如果满足：

> 对于图`G`中的任意一条有向边`(u,v)`，`u`在排列中都出现在`v`的前面。

那么称该排列是图`G`的**拓扑排序**。

**两条重要性质**:

- 如果图`G`中存在环（即图`G`不是**有向无环图**），那么图`G`不存在拓扑排序。
- 如果图`G`是有向无环图，那么它的拓扑排序可能不止一种。

题目：#210

---
