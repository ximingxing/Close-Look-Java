# Graph

## 图论基础

图的基本存储方式：

1. 邻接表

**做法**：我把每个节点`x`的邻居都存到一个列表里，然后把`x`和这个列表关联起来，这样就可以通过一个节点`x`找到它的所有相邻节点。
**优势**：占用存储空间少。
**劣势**：邻接表无法快速判断两个节点是否相邻。

2. 邻接矩阵

**做法**：邻接矩阵则是一个二维布尔数组`matrix`，如果节点`x`和`y`是相连的，那么就把`matrix[x][y]`设为`true`。
**优势**：快速判断两个节点是否相邻，如`matrix[1][3]=true`表示节点1和节点3相邻。
**劣势**：占用的存储空间大，如果图是稀疏的，则会浪费很多空间。

**有向加权图**的存储方式改进：

1. 对于邻接表来说，不仅存储节点`x`的全部邻居节点，还存储`x`到邻居节点的权重。

2. 对于邻接矩阵来说，将二维布尔数组转变为二位int或者float型数组，表示节点的权重。

**无向加权图**的存储方式改进：

对于无向图等价于**节点双向连接**，即`matrix[x][y] = true`和`matrix[y][x] = true`。

## 图的遍历

**由于图中可能存在环**，所以图的遍历需要借助`visited`数组。

```java
class Traverse {
    boolean[] visited; // Noting！

    void traverse(Graph graph, int s) {
        if (visited[s]) return;
        
        // 经过节点s
        visited[s] = true;
        // 遍历节点s的邻居节点
        for(Node node: graph.neighbors(s)) {
            traverse(neighbors);
        }
        //离开节点s
        visited[s] = false;
    }
}
```

---

### 循环不变量

定义: 声明的变量在遍历的过程中保持定义不变.

For example: **荷兰国旗问题**

Solution: `[0, i)`均为`0`, `[i, j)`均为`1`, `[j, k]`未知, `[k+1, nums.length-1)`均为`2`.

注意: 这个式子在循环的过程中定义不改变, 仅改变变量的取值.

题目：#75

---
