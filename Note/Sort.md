# 排序算法

常用排序算法总结.

题目: #148

---

### 归并排序(Merge Sort)

**归并**, 即将两个有序的数组归并成一个更大的有序数组.

要将一个数组排序, 可以先(递归地)将它分成两半分别排序, 然后将结果归并起来.

- 时间复杂度: `O(NlogN)`;
- 空间复杂度: `O(N)`.

#### 原地归并的抽象方法

`void merge(Comparable[] a, int lo, int mid, int hi)` 是两个不同的有序数组归并到第三个数组中的方法.

具体来说, 将涉及的所有元素复制到一个辅助数组`aux`中, 再把归并的结果放回原数组中.

```java
class Merge {
    /* 将a[lo..mid]和a[mid+1..hi]归并成一个有序的数组并将结果存放在a[lo..hi]中 */
    void merge(Comparable[] a, int lo, int mid, int hi) { 
        // 将 a[lo..mid] 和 a[mid+1..hi] 归并
        int i = lo, j = mid+1;
        
        // 将 a[lo..hi] 复制到 aux[lo..hi] 
        for (int k = lo; k <= hi; k++) 
            aux[k] = a[k];
        
        // 归并回到 a[lo..hi]
        for (int k = lo; k <= hi; k++)  
            if (i > mid) a[k] = aux[j++]; 
            else if (j > hi) a[k] = aux[i++]; 
            else if (less(aux[j], aux[i])) a[k] = aux[j++]; 
            else a[k] = aux[i++];
    }
}
```

#### 自顶向下的归并排序

应用高效算法设计中**分治思想**的最典型的一个例子:

```java
class Merge{
    Comparable[] aux; // 归并所需的辅助数组

    void sort(Comparable[] a){
        aux = new Comparable[a.length]; // 一次性分配空间 
        sort(a, 0, a.length - 1);
    }

    void sort(Comparable[] a, int lo, int hi) { // 将数组a[lo..hi]排序
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid); // 将左半边排序
        sort(a, mid+1, hi); // 将右半边排序
        merge(a, lo, mid, hi); // 归并结果(代码见“原地归并的抽象方法”)
    } 
}
```

---

### 快速排序(Quick Sort)

快速排序是一种分治的排序算法, 它将一个数组分成两个子数组, 将两部分独立地排序.

快速排序将数组排序的方式是当两个子数组都有序时整个数组也就自然有序.

- 时间复杂度: `O(NlogN)`;
- 空间复杂度: `O(logN)`.

```
{ E C A I E } K { L P U T M Q R X O S }
              | 
             split 
```

`split`切分元素左边不大于它, 右边不小于它.

一次快排的过程就是将数组分割成两部分, 
一部分比基准值大, 另一部分比基准值小, 然后再分治前一部分和后一部分.

#### 快速排序框架

```java
class Quick{
    void sort(Comparable[] a){
        sort(a, 0, a.length - 1);
    }

    void sort(Comparable[] a, int lo, int hi){
        // 递归出口
        if (hi <= lo) return;
        // 快速排序切分
        int j = partition(a ,lo, hi);
        // 将左半边部分a[lo, j-1]排序
        sort(a, lo, j-1);
        // 将右半边部分a[j+1, hi]排序
        sort(a, j+1, hi);
    }
}
```

该方法的关键在于**切分**, 这个过程使得数组满足下面三个条件:

1. 对于某个`j`, `a[j]`已经排定;

2. `a[lo]`到`a[j-1]`中的所有元素都不大于`a[j]`;

3. `a[j+1]`到`a[hi]`中的所有元素都不小于`a[j]`.

我们就是通过递归地调用切分来排序的.

**用归纳法不难证明递归能够正确地将数组排序:
如果左子数组和右子数组都是有序的，那么由左子数组(有序且没有任何元素大于切分元素)、
切分元素和右子数组(有序且没有任何元素小于切分元素)组成的结果数组也一定是有序的**.

#### 快速排序切分的实现

要完成这个实现，需要实现切分方法。

一般策略是先 随意地取`a[lo]`作为切分元素，即那个将会被排定的元素，
然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，
再从数组的右端开始向左扫描直到找到一个小于等于它的元素。
这两个元素显然是没有排定的，因此我们交换它们的位置。
如此继续，我们就可以保证左指针 `i` 的左侧元素都不大于切分元素，右指针 `j` 的右侧元素都不小于切分元素。
当两个指针相遇时，我们只需要将切分元素 `a[lo]` 和左子数组最右侧的元素(`a[j]`)交换然后返 回 `j` 即可。

```java
class Quick{
    int partition(Comparable[] a, int lo, int hi){
        // 左右扫描的指针
        int i = lo, j = hi;
        // 切分元素
        Comparable v = a[i];
        
        while (true){
            // 扫描左右, 检查扫描是否结束并交换元素
            while (less(a[++i], v)) if (i == hi) break;
            while (less(v, a[--j])) if (j == lo) break;
            if (i >= j) break;
            exch(a ,i ,j);           
        }
        // 将 v = a[j] 放入正确位置
        exch(a ,lo, j);
        // a[lo, j-1] <= a[j] <= a[j+1, hi] 达成
        return j;
    }
}
```

#### 快速排序的改进 

##### 改进一: **切换到插入排序**

1. 对于小数组而言, 快速排序比插入排序慢;

2. 因为递归, 快速排序的`sort()`方法在小数组中也会调用自己.

**因此, 在排序小数组时应该切换到插入排序**.

将排序中的:
```
if (hi <= lo) return;
```

变为:
```
if (hi <= lo + M) { Insertion.sort(a, lo, hi); return; }
```

转换参数`M`的最佳值是和系统相关的, 但是`5 ~ 15`之间的任意值在大多数情况下都能令人满.

##### 改进二: **三取样切分**

改进快速排序性能的第二个办法是使用子数组的一小部分元素的中位数来切分数组.

这样做得到的切分更好, 但代价是需要计算中位数.

人们发现将取样大小设为`3`并用大小居中的元素切分的效果最好.

```java
class Quick3way{
    void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int lt = lo, i = lo+1, gt = hi;
        Comparable v = a[lo];
        // 处理 [i, gt] 中未确定的元素
        while (i <= gt) {
            int cmp = a[i].compareTo(v);
            // a[i] < v
            if      (cmp < 0) exch(a, lt++, i++);
            // a[i] > v
            else if (cmp > 0) exch(a, i, gt--);
            // a[i] == v
            else     i++;
        } 
    // 现在 a[lo..lt-1] < v = a[lt..gt] < a[gt+1..hi]成立 
    sort(a, lo, lt - 1);
    sort(a, gt + 1, hi);
    } 
}
```

它从左到右遍历数组一次,
维护一个指针`lt`使得`a[lo..lt-1]`中的元素都小于`v`,
一个指针`gt`使得`a[gt+1..hi]`中的元素都大于`v`,
一个指针`i`使得`a[lt..i-1]`中的元素都等于`v`,
`a[i..gt]`中的元素都还未确定.

---

### 快速排序与归并排序的总结

快速排序和归并排序是互补的:

**归并排序将数组分成两个子数组分别排序, 并将有序的子数组归并以将整个数组排序**;

**而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了**.

在归并排序中, 递归调用发生在处理整个数组之前;

在快速排序中, 递归调用发生在处理整个数组之后.

**在归并排序中, 一个数组被等分为两半; 在快速排序中, 切分(partition)的位置取决于数组的内容**.

---

### 桶排序算法

将待排序的序列分到若干个桶中, 每个桶内的元素再进行个别排序。

**桶排序重要的是它的思想, 而不是具体实现**.

题目: #220

---

### 堆排序

> 参考[堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，
它的最坏、最好、平均时间复杂度均为`O(NlogN)`，它也是不稳定排序。

堆是具有以下性质的完全二叉树：**每个结点的值都大于或等于其左右孩子结点的值**，称为大顶堆；
或者**每个结点的值都小于或等于其左右孩子结点的值**，称为小顶堆。

大顶堆：`arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]`

小顶堆：`arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]`

**堆排序思路**:

1. 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

2. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。

题目: #215